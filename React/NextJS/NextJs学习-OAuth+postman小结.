## [Authorization Code flow with  PKCE](#top)

- [Authorization for Single-page apps(browser-based apps)](#authorization-for-single-page-appsbrowser-based-apps)
- [set up Authorization Code flow (with PKCE) in Postman](#set-up-authorization-code-flow-with-pkce-in-postman)

---------------------------------------------------------------------

- **PKCE (Proof Key for Code Exchange)** is an extension to the Authorization Code flow to prevent certain attacks and to be able to securely perform the OAuth exchange from public clients
- **Roles**
  - The Third-Party Application: "Client"
  - The API: "Resource Server"
  - The Authorization Server: may be the same server as the API server, but larger scale deployments will often build this as a separate component
  - The User: "Resource Owner"

```mermaid
sequenceDiagram
  autonumber
  actor U as user
  participant C as client(Browser)
  participant A as Authorization Server
  participant API as Your API
  U->>C: click login link
  C->>C: 
  C->>A: request Authorization code + Challenge
  A->>U: redirect to login/authorization prompt
  U->>A: authenticate and consent
  A->>C: send authorization code + verifier
  A->>A: validate code verifier + Challenge
  A->>C: provide ID token and access token
  C->>API: request user data with access token
  API->>C: send response
```

[⬆️back to top](#top)

## Authorization for Single-page apps(browser-based apps)

- The first step of OAuth 2 is to get authorization from the user
   - For browser-based or mobile apps, this is usually accomplished by displaying an interface provided by the service to the user
- OAuth 2 provides several "grant types" for different use cases. The grant types defined are:
  - **Authorization Code** for apps running on a web server, browser-based and mobile apps
  - **Password** for logging in with a username and password (only for first-party apps)
  - **Client credentials** for application access without a user present
  - **Implicit** was previously recommended for clients without a secret, but has been superseded by using the Authorization Code grant with PKCE
- **For Single-page apps(browser-based apps)**
1. Create **Secret**(a random string between 43-128 characters long), then generate the url-safe base64-encoded SHA256 **hash** of the string
   1. **Secret(code verifier**)**: Create a random string , e.g '5d2309e5bb73b864f989753887fe52f79ce5270395e25862da6940d5'
   2. **hash(code challenge): Create the SHA256 hash, then base64-encode the string, e.g 'MChCW5vD-3h03HMGFZYskOSTir7II_MMTb8a9rJNhnI'
2. Create a "Log In" link include the code challenge
  - **`https://authorization-server.com/auth?response_type=code&
  client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=photos&state=1234zyx&code_challenge=CODE_CHALLENGE&code_challenge_method=S256`**
  - <mark>response_type=code</mark> - Indicates that your server expects to receive an authorization code
  - <mark>client_id</mark> - The client ID you received when you first created the application
  - <mark>redirect_uri</mark> - Indicates the URI to return the user to after authorization is complete
  - <mark>scope</mark> - One or more scope values indicating which parts of the user's account you wish to access
  - <mark>state</mark> - A random string generated by your application, which you'll verify later
  - <mark>code_challenge</mark> - The URL-safe base64-encoded SHA256 hash of the secret
  - <mark>code_challenge_method=S256</mark> - Indicate which hashing method you used (S256)
1. The user sees the authorization prompt in web UI
2. If the user clicks "Allow," the service redirects the user back to your site with an auth code
   - `https://example-app.com/cb?code=AUTH_CODE_HERE&state=1234zyx `
   - **code** - The server returns the authorization code in the query string
   - **state** - The server returns the same state value that you passed
   - You can typically store the state value in a cookie, and compare it when the user comes back
3. Get the authorization code for an **access token** from authorization server
   - send the PKCE secret you generated at the beginning of the flow
   - `POST https://api.authorization-server.com/token`
   - `grant_type=authorization_code&code=AUTH_CODE_HERE&redirect_uri=REDIRECT_URI&client_id=CLIENT_ID&code_verifier=CODE_VERIFIER`
   - `grant_type=authorization_code` - The grant type for this flow is authorization_code
   - `code=AUTH_CODE_HERE` - This is the code you received in the query string
   - `redirect_uri=REDIRECT_URI` - Must be identical to the redirect URI provided in the original link
   - `client_id=CLIENT_ID` - The client ID you received when you first created the application
   - `code_verifier=CODE_VERIFIER` - The random secret you generated at the beginning
   - The authorization server will hash the verifier and compare it to the challenge sent in the request, and **only issue(return)** the access token if they match
- ![OAuth-swimlane](./images/OAuth-swimlane.png)

[⬆️back to top](#top)

## set up Authorization Code flow (with PKCE) in Postman

- In Postman, under the '**Authorization**' tab of any request, select OAuth 2.0
- Click '**Get New Access Token**'
- Select a '**Grant Type**' of `Authorization Code (With PKCE)`
- The '**Code Challenge Method**' can be either SHA-256 or Plain
- You can also optionally provide a custom **Code Verifier**
- ![OAuth-swimlane](OAuth-swimlane.png)

> References
- [OAuth 2 Simplified](https://aaronparecki.com/oauth-2-simplified/#single-page-apps)
- [postman - various OAuth 2.0 flows](https://www.postman.com/postman/postman-team-collections/collection/gc4nhm0/oauth-2-0?deviceId=eb5abf87-a90f-46da-9c22-c13cd69e37d1)
- [OAuth 2.0: Implicit Flow is Dead, Try PKCE Instead](https://blog.postman.com/pkce-oauth-how-to)
